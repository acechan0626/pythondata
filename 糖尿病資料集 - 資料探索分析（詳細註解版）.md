# 糖尿病資料集 - 資料探索分析（詳細註解版）

以下是在 Google Colab 中進行資料探索的完整程式碼，每一行都有詳細的中文註解說明。

## **步驟 1：環境設定與載入資料**

```python
# 引入pandas函式庫，用於資料處理和分析
import pandas as pd

# 引入matplotlib.pyplot，用於基本的圖表繪製
import matplotlib.pyplot as plt

# 引入seaborn，用於統計圖表的美化和進階視覺化
import seaborn as sns

# 引入numpy，用於數值計算和陣列操作
import numpy as np

# 引入warnings模組，用於控制警告訊息的顯示
import warnings

# 引入requests，用於發送HTTP請求下載網路資料
import requests

# 引入io模組，用於處理輸入輸出流
import io

# 設定忽略未來版本的警告訊息，避免干擾輸出結果
warnings.simplefilter(action='ignore', category=FutureWarning)

# 設定matplotlib圖表在螢幕上的解析度為100 DPI
plt.rcParams['figure.dpi'] = 100

# 設定儲存圖表時的解析度為300 DPI，確保高品質輸出
plt.rcParams['savefig.dpi'] = 300

# --- 載入資料 ---
# 使用try-except結構來處理可能的載入錯誤
try:
    # 定義資料集的網路位址
    url = "https://github.com/acechan0626/pythondata/raw/main/pima-indians-diabetes.csv"
    
    # 使用pandas的read_csv函數從URL直接讀取CSV檔案
    df = pd.read_csv(url)
    
    # 顯示成功載入的訊息
    print("✅ 資料集從URL成功載入！")
    
    # 顯示資料集的形狀（行數, 列數）
    print(f"資料集形狀：{df.shape}")
    
    # 顯示換行符號，讓輸出更清楚
    print("\n資料集前五筆記錄：")
    
    # 顯示資料集的前五筆記錄
    print(df.head())
    
    # 再次顯示換行符號
    print("\n資料集基本資訊：")
    
    # 顯示資料集的基本資訊（欄位名稱、資料型別、非空值數量等）
    print(df.info())

# 如果從URL載入失敗，執行except區塊
except Exception as e:
    # 顯示錯誤訊息，其中{e}會顯示具體的錯誤內容
    print(f"❌ 從URL載入失敗：{e}")
    
    # 提示使用者嘗試本地檔案
    print("請嘗試上傳本地檔案...")
    
    # 嘗試從本地檔案載入（備用方案）
    try:
        # 從當前目錄讀取CSV檔案
        df = pd.read_csv('pima-indians-diabetes.csv')
        
        # 顯示本地載入成功的訊息
        print("✅ 資料集從本地檔案成功載入！")
        
        # 顯示資料集形狀
        print(f"資料集形狀：{df.shape}")
        
        print("\n資料集前五筆記錄：")
        
        # 顯示前五筆記錄
        print(df.head())
        
    # 如果本地檔案也找不到，顯示錯誤訊息
    except FileNotFoundError:
        print("❌ 錯誤：找不到 'pima-indians-diabetes.csv'。")
        print("請先在 Colab 左側的「檔案」面板中上傳檔案。")
```

## **步驟 2：資料基本統計摘要**

```python
# 檢查變數df是否存在於本地變數中（確保資料已成功載入）
if 'df' in locals():
    # 顯示統計摘要的標題
    print("=== 資料基本統計摘要 ===")
    
    # 顯示數值欄位的描述性統計（平均值、標準差、最小值、最大值等）
    print(df.describe())
    
    # 顯示目標變數分析的標題
    print("\n=== 目標變數分布 ===")
    
    # 檢查是否存在'Class'欄位（目標變數）
    if 'Class' in df.columns:
        # 計算並顯示Class欄位中各類別的數量
        print(df['Class'].value_counts())
        
        # 計算糖尿病陽性的比例（Class=1的比例），並格式化為百分比
        print(f"糖尿病陽性比例：{df['Class'].mean():.2%}")
```

## **步驟 3：繪製直方圖 (Histograms)**

```python
# --- 1. 直方圖 (Histograms) ---
# 再次檢查df是否存在
if 'df' in locals():
    # 顯示正在生成直方圖的訊息
    print("\n--- 正在生成直方圖 ---")
    
    # 選擇資料集中所有數值型別的欄位（float64和int64）
    numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns.tolist()
    
    # 檢查'Class'是否在數值欄位中
    if 'Class' in numeric_cols:
        # 建立特徵欄位列表，排除目標變數'Class'
        feature_cols = [col for col in numeric_cols if col != 'Class']
    else:
        # 如果沒有'Class'欄位，所有數值欄位都視為特徵
        feature_cols = numeric_cols
    
    # 設定子圖的列數為3
    n_cols = 3
    
    # 計算需要的行數，使用無條件進位除法
    n_rows = (len(feature_cols) + n_cols - 1) // n_cols

    # 建立子圖，設定圖片大小為寬15英寸，高度根據行數調整
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, n_rows * 4))
    
    # 處理axes的維度問題
    if n_rows == 1:
        # 如果只有一行，根據列數決定axes的格式
        axes = [axes] if n_cols == 1 else axes
    else:
        # 如果有多行，將二維陣列攤平成一維陣列，方便迭代
        axes = axes.flatten()

    # 迭代每個特徵欄位，同時取得索引和欄位名稱
    for i, col in enumerate(feature_cols):
        # 確保索引不超過axes的長度
        if i < len(axes):
            # 使用seaborn繪製直方圖，同時顯示核密度估計曲線
            # kde=True 表示顯示核密度估計
            # alpha=0.7 設定透明度
            sns.histplot(df[col], kde=True, ax=axes[i], alpha=0.7)
            
            # 設定子圖標題，使用格式化字串插入欄位名稱
            axes[i].set_title(f'Distribution of {col}', fontsize=12, fontweight='bold')
            
            # 設定x軸標籤
            axes[i].set_xlabel(col)
            
            # 設定y軸標籤
            axes[i].set_ylabel('Frequency')
            
            # 添加網格線，alpha=0.3設定網格線的透明度
            axes[i].grid(True, alpha=0.3)

    # 隱藏多餘的子圖（當特徵數量不能整除列數時）
    for i in range(len(feature_cols), len(axes)):
        # 刪除多餘的子圖
        fig.delaxes(axes[i])

    # 自動調整子圖間距，避免重疊
    plt.tight_layout()
    
    # 儲存圖片，bbox_inches='tight'確保完整保存，dpi=300設定高解析度
    plt.savefig('histograms.png', bbox_inches='tight', dpi=300)
    
    # 顯示圖片
    plt.show()
    
    # 顯示完成訊息
    print("✅ 直方圖已生成並顯示，並儲存為 histograms.png")
```

## **步驟 4：繪製箱型圖 (Box Plots)**

```python
# --- 2. 箱型圖 (Box Plots) ---
# 檢查df是否存在
if 'df' in locals():
    # 顯示正在生成箱型圖的訊息
    print("\n--- 正在生成箱型圖 ---")
    
    # 建立子圖，使用與直方圖相同的佈局
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, n_rows * 4))
    
    # 處理axes的維度問題（與直方圖相同的邏輯）
    if n_rows == 1:
        axes = [axes] if n_cols == 1 else axes
    else:
        axes = axes.flatten()

    # 迭代每個特徵欄位
    for i, col in enumerate(feature_cols):
        # 確保索引不超過axes的長度
        if i < len(axes):
            # 使用seaborn繪製箱型圖
            # x=df[col] 指定要繪製的資料
            sns.boxplot(x=df[col], ax=axes[i])
            
            # 設定子圖標題
            axes[i].set_title(f'Box Plot of {col}', fontsize=12, fontweight='bold')
            
            # 設定x軸標籤
            axes[i].set_xlabel(col)
            
            # 添加網格線
            axes[i].grid(True, alpha=0.3)

    # 隱藏多餘的子圖
    for i in range(len(feature_cols), len(axes)):
        fig.delaxes(axes[i])

    # 自動調整佈局
    plt.tight_layout()
    
    # 儲存圖片
    plt.savefig('boxplots.png', bbox_inches='tight', dpi=300)
    
    # 顯示圖片
    plt.show()
    
    # 顯示完成訊息
    print("✅ 箱型圖已生成並顯示，並儲存為 boxplots.png")
```

## **步驟 5：繪製相關矩陣 (Correlation Matrix)**

```python
# --- 3. 相關矩陣 (Correlation Matrix) ---
# 檢查df是否存在
if 'df' in locals():
    # 顯示正在生成相關矩陣的訊息
    print("\n--- 正在生成相關矩陣熱力圖 ---")
    
    # 計算所有數值欄位之間的皮爾森相關係數矩陣
    corr_matrix = df[numeric_cols].corr()

    # 建立新的圖片，設定大小為12x10英寸
    plt.figure(figsize=(12, 10))
    
    # 建立上三角遮罩，避免重複顯示相關係數
    # np.triu建立上三角矩陣，np.ones_like建立與corr_matrix相同形狀的矩陣
    mask = np.triu(np.ones_like(corr_matrix, dtype=bool))
    
    # 使用seaborn繪製熱力圖
    sns.heatmap(corr_matrix,           # 要繪製的資料矩陣
                mask=mask,             # 遮罩，隱藏上三角部分
                annot=True,            # 在每個格子中顯示數值
                cmap='coolwarm',       # 使用冷暖色調的色彩映射
                fmt='.2f',             # 數值格式，保留兩位小數
                center=0,              # 色彩映射的中心點設為0
                square=True,           # 每個格子都是正方形
                cbar_kws={"shrink": .8})  # 色彩條的大小調整為80%
    
    # 設定圖片標題，pad=20增加標題與圖片的間距
    plt.title('Correlation Matrix of Numerical Features', 
              fontsize=16, fontweight='bold', pad=20)
    
    # 自動調整佈局
    plt.tight_layout()
    
    # 儲存圖片
    plt.savefig('correlation_matrix.png', bbox_inches='tight', dpi=300)
    
    # 顯示圖片
    plt.show()
    
    # 顯示完成訊息
    print("✅ 相關矩陣熱力圖已生成並顯示，並儲存為 correlation_matrix.png")
    
    # 顯示高相關性變數對的標題
    print("\n=== 高相關性變數對 (|r| > 0.5) ===")
    
    # 建立空列表來儲存高相關性的變數對
    high_corr = []
    
    # 雙重迴圈遍歷相關矩陣的下三角部分
    for i in range(len(corr_matrix.columns)):        # 外層迴圈：行
        for j in range(i+1, len(corr_matrix.columns)): # 內層迴圈：列（從i+1開始避免重複）
            # 取得相關係數值
            corr_val = corr_matrix.iloc[i, j]
            
            # 如果絕對值大於0.5，視為高相關性
            if abs(corr_val) > 0.5:
                # 將變數對和相關係數加入列表
                high_corr.append((corr_matrix.columns[i], corr_matrix.columns[j], corr_val))
    
    # 檢查是否找到高相關性的變數對
    if high_corr:
        # 迭代並顯示每個高相關性變數對
        for var1, var2, corr_val in high_corr:
            # 使用箭頭符號顯示變數對，保留三位小數
            print(f"{var1} ↔ {var2}: {corr_val:.3f}")
    else:
        # 如果沒有找到，顯示相應訊息
        print("沒有發現高相關性的變數對")
```

## **步驟 6：繪製 Pairplot**

```python
# --- 4. Pairplot ---
# 檢查df是否存在
if 'df' in locals():
    # 顯示正在生成Pairplot的訊息
    print("\n--- 正在生成 Pairplot (這可能需要一些時間) ---")
    
    # 檢查是否存在'Class'欄位
    if 'Class' in df.columns:
        # 選擇一些代表性的特徵來繪製pairplot
        # 避免包含太多變數導致圖片過於擁擠和計算時間過長
        selected_cols = ['Glucose_concentration', 'Blood_pressure', 'BMI', 'Age', 'Class']
        
        # 確保所選的欄位都存在於資料集中
        # 使用列表推導式過濾存在的欄位
        selected_cols = [col for col in selected_cols if col in df.columns]
        
        # 檢查是否有足夠的欄位來繪製pairplot（至少需要2個）
        if len(selected_cols) > 1:
            # 建立資料的副本，避免修改原始資料
            df_pairplot = df[selected_cols].copy()
            
            # 檢查副本中是否包含'Class'欄位
            if 'Class' in df_pairplot.columns:
                # 將'Class'欄位轉換為類別型別，以獲得更好的圖例顯示
                df_pairplot['Class'] = df_pairplot['Class'].astype('category')
                
                # 繪製pairplot，根據Class進行顏色分組
                g = sns.pairplot(df_pairplot,           # 要繪製的資料
                               hue='Class',             # 根據Class欄位進行顏色分組
                               diag_kind='kde',         # 對角線圖表類型為核密度估計
                               plot_kws={'alpha': 0.6}, # 散佈圖的透明度
                               diag_kws={'alpha': 0.7}) # 對角線圖的透明度
                
                # 設定整個圖片的主標題
                # y=1.02 將標題稍微向上移動，避免與圖片重疊
                g.fig.suptitle('Pairplot of Selected Features by Diabetes Class', 
                              y=1.02, fontsize=16, fontweight='bold')
            else:
                # 如果沒有Class欄位，繪製不分組的pairplot
                g = sns.pairplot(df_pairplot, diag_kind='kde')
                g.fig.suptitle('Pairplot of Selected Features', 
                              y=1.02, fontsize=16, fontweight='bold')
            
            # 儲存圖片
            plt.savefig('pairplot.png', bbox_inches='tight', dpi=300)
            
            # 顯示圖片
            plt.show()
            
            # 顯示完成訊息
            print("✅ Pairplot 已生成並顯示，並儲存為 pairplot.png")
        else:
            # 如果欄位數量不足，顯示錯誤訊息
            print("❌ 沒有足夠的欄位來繪製pairplot")
    else:
        # 如果找不到Class欄位，顯示錯誤訊息
        print("❌ 找不到Class欄位，無法進行分類著色")

# 顯示所有圖表生成完畢的訊息
print("\n🎉 所有圖表生成完畢！")
```

## **步驟 7：額外分析 - 按類別分組的統計摘要**

```python
# --- 5. 按類別分組的統計分析 ---
# 檢查df是否存在且包含'Class'欄位
if 'df' in locals() and 'Class' in df.columns:
    # 顯示分組統計分析的標題
    print("\n--- 按糖尿病類別分組的統計摘要 ---")
    
    # 按'Class'欄位分組，計算特徵欄位的統計摘要
    # agg(['mean', 'std', 'median']) 計算平均值、標準差和中位數
    grouped_stats = df.groupby('Class')[feature_cols].agg(['mean', 'std', 'median'])
    
    # 顯示各類別下特徵的平均值
    print("各特徵在不同類別下的平均值：")
    # xs('mean', level=1, axis=1) 提取第二層索引為'mean'的資料
    # round(3) 四捨五入到三位小數
    print(grouped_stats.xs('mean', level=1, axis=1).round(3))
    
    # 顯示各類別下特徵的標準差
    print("\n各特徵在不同類別下的標準差：")
    print(grouped_stats.xs('std', level=1, axis=1).round(3))
    
    # 引入scipy.stats模組進行統計檢驗
    from scipy import stats
    
    # 顯示統計檢驗的標題
    print("\n=== 組間差異顯著性檢驗 (t-test) ===")
    
    # 對每個特徵進行獨立樣本t檢驗
    for col in feature_cols:
        # 提取Class=0組的資料
        group_0 = df[df['Class'] == 0][col]
        
        # 提取Class=1組的資料
        group_1 = df[df['Class'] == 1][col]
        
        # 進行獨立樣本t檢驗
        # 返回t統計量和p值
        t_stat, p_value = stats.ttest_ind(group_0, group_1)
        
        # 根據p值判斷顯著性水準
        # 使用三元運算子進行多層條件判斷
        significance = "***" if p_value < 0.001 else "**" if p_value < 0.01 else "*" if p_value < 0.05 else ""
        
        # 顯示檢驗結果，包含t統計量、p值和顯著性標記
        print(f"{col}: t={t_stat:.3f}, p={p_value:.4f} {significance}")
    
    # 顯示顯著性水準的說明
    print("\n註：* p<0.05, ** p<0.01, *** p<0.001")
```

## **簡化版本（適合初學者）**

```python
# === 簡化版本 - 適合初學者和快速教學 ===

# 引入必要的函式庫
import pandas as pd          # 資料處理
import matplotlib.pyplot as plt  # 基本繪圖
import seaborn as sns        # 統計繪圖
import numpy as np           # 數值計算
import warnings              # 警告控制

# 忽略警告訊息
warnings.simplefilter(action='ignore', category=FutureWarning)

# 從網路載入資料
url = "https://github.com/acechan0626/pythondata/raw/main/pima-indians-diabetes.csv"
df = pd.read_csv(url)        # 讀取CSV檔案
print("資料載入成功！")       # 顯示成功訊息

# 選擇數值型欄位
numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns.tolist()
# 排除目標變數，只保留特徵
feature_cols = [col for col in numeric_cols if col != 'Class']

# === 1. 直方圖 ===
n_cols = 3  # 每行3個子圖
# 計算需要的行數
n_rows = (len(feature_cols) + n_cols - 1) // n_cols
# 建立子圖
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, n_rows * 4))
axes = axes.flatten()  # 攤平陣列

# 為每個特徵繪製直方圖
for i, col in enumerate(feature_cols):
    sns.histplot(df[col], kde=True, ax=axes[i])  # 繪製直方圖+密度曲線
    axes[i].set_title(f'Histogram of {col}')     # 設定標題

# 刪除多餘的子圖
for i in range(len(feature_cols), len(axes)):
    fig.delaxes(axes[i])

plt.tight_layout()           # 調整佈局
plt.savefig('histograms.png') # 儲存圖片
plt.show()                   # 顯示圖片

# === 2. 箱型圖 ===
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, n_rows * 4))
axes = axes.flatten()

# 為每個特徵繪製箱型圖
for i, col in enumerate(feature_cols):
    sns.boxplot(x=df[col], ax=axes[i])           # 繪製箱型圖
    axes[i].set_title(f'Box Plot of {col}')     # 設定標題

# 刪除多餘的子圖
for i in range(len(feature_cols), len(axes)):
    fig.delaxes(axes[i])

plt.tight_layout()
plt.savefig('boxplots.png')
plt.show()

# === 3. 相關矩陣 ===
plt.figure(figsize=(10, 8))                     # 設定圖片大小
corr_matrix = df[numeric_cols].corr()           # 計算相關矩陣
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f')  # 繪製熱力圖
plt.title('Correlation Matrix')                 # 設定標題
plt.savefig('correlation_matrix.png')           # 儲存圖片
plt.show()                                      # 顯示圖片

# === 4. Pairplot ===
# 選擇重要的欄位
selected_cols = ['Glucose_concentration', 'Blood_pressure', 'BMI', 'Age', 'Class']
# 確保欄位存在
selected_cols = [col for col in selected_cols if col in df.columns]
# 繪製pairplot，按Class分組著色
sns.pairplot(df[selected_cols], hue='Class', diag_kind='kde')
plt.savefig('pairplot.png')                     # 儲存圖片
plt.show()                                      # 顯示圖片

print("所有圖表生成完畢！")                      # 顯示完成訊息
```

## **註解說明重點**

1. **變數命名**：每個變數的用途都有清楚說明
2. **函數參數**：每個重要參數的作用都有註解
3. **邏輯流程**：條件判斷和迴圈的邏輯都有說明
4. **錯誤處理**：try-except結構的用途有詳細解釋
5. **圖表設定**：每個圖表參數的意義都有說明

這個詳細註解版本非常適合教學使用，學生可以通過註解理解每一行程式碼的作用和原理！
